/**
 * Copyright 2005-2013 The Kuali Foundation
 *
 * Licensed under the Educational Community License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.opensource.org/licenses/ecl2.php
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.kuali.rice.krad.data.provider.jpa.eclipselink;

import org.apache.commons.lang.ObjectUtils;
import org.eclipse.persistence.config.DescriptorCustomizer;
import org.eclipse.persistence.config.SessionCustomizer;
import org.eclipse.persistence.descriptors.ClassDescriptor;
import org.eclipse.persistence.internal.databaseaccess.Accessor;
import org.eclipse.persistence.internal.sessions.AbstractSession;
import org.eclipse.persistence.mappings.DatabaseMapping;
import org.eclipse.persistence.sessions.JNDIConnector;
import org.eclipse.persistence.sessions.Session;
import org.kuali.rice.krad.data.platform.generator.Sequence;
import org.kuali.rice.krad.data.platform.generator.DatabasePlatformIdGenerator;
import org.kuali.rice.krad.data.platform.generator.IdGenerator;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.ConnectionCallback;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.util.ReflectionUtils;

import javax.persistence.GeneratedValue;
import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;

/**
 * EclipseLink Descriptor and Session Customizer which parses {@link org.kuali.rice.krad.data.platform.generator.Sequence}
 * annotations and automatically registers custom EclipseLink Sequences.
 *
 * This class is registered as both a {@link DescriptorCustomizer} and a {@link SessionCustomizer}.  Since these
 * are both stateless instances, and because concrete {@link org.eclipse.persistence.sequencing.Sequence} objects
 * must be registered individually with the EclipseLink session, we store the Sequence objects generated by
 * annotation inspection until the later SessionCustomizer phase, at which point we register them.  Therefore this
 * implementation relies on the specific documented ordering of EclipseLink customization phases (and in absence
 * of that guarantee, exhibits a race condition on the generated Sequences).
 */
public class EclipseLinkSequenceCustomizer implements DescriptorCustomizer, SessionCustomizer {
    /**
     * Store the Sequences generated in the DescriptorCustomizer phase for registration during the
     * SessionCustomizer phase
     */
    private static List<org.eclipse.persistence.sequencing.Sequence> sequences = new ArrayList<org.eclipse.persistence.sequencing.Sequence>();

    @Override
    public void customize(ClassDescriptor descriptor) throws Exception {
        // obtain the entity class
        // for each mapping on the identity class, if it is an @Id mapping, and a Sequence annotation
        // exists, construct and save the respective IdGenerator and EclipseLink Sequence wrapper.
        // If the attributed is NOT marked with the @GeneratedValue annotation, programmatically
        // register the Sequence with the attribute
        // NOTE: it is NOT sufficient to merely assign the constructed Sequence object to the ClassDescriptor
        // The sequenceNumberName and sequenceNumberField must also be set, and the Sequence instance must be added
        // to the EclipseLink session (presumably because EclipseLink performs a phase itself which manually wires
        // the sequence to the attribute)
        Class entityClass = descriptor.getJavaClass();
        Sequence classSequence = (Sequence) AnnotationUtils.findAnnotation(entityClass, Sequence.class);
        Vector<DatabaseMapping> mappings = descriptor.getMappings();
        for (DatabaseMapping mapping: mappings) {
            if (!mapping.isJPAId()) {
                continue;
            }

            Field field = ReflectionUtils.findField(entityClass, mapping.getAttributeName());
            if (field == null) continue;

            Sequence fieldSequence = AnnotationUtils.getAnnotation(field, Sequence.class);
            Sequence resolvedSequence = (Sequence) ObjectUtils.defaultIfNull(fieldSequence, classSequence);

            if (resolvedSequence != null) {
                // NOTE: JPA entities may only have *ONE* GeneratedValue Id
                // so we just have to assume the first one we encounter has defined the
                // Sequence/Generator for the entire class descriptor
                IdGenerator generator = new DatabasePlatformIdGenerator(resolvedSequence.name());
                org.eclipse.persistence.sequencing.Sequence sequence = new IdGeneratorSequenceWrapper(generator);
                sequences.add(sequence);

                // If the attributed is NOT marked with the @GeneratedValue annotation, programmatically
                // register the Sequence with the attribute
                GeneratedValue generatedValue = AnnotationUtils.getAnnotation(field, GeneratedValue.class);
                if (generatedValue == null) {
                    assignSequence(descriptor, mapping, sequence);
                }

                break;
            }
        }
    }

    /**
     * Should perform the equivalent of @GeneratedValue(generator="custom_generator_name")
     * @param descriptor the ClassDescriptor to register the sequence on
     * @param mapping the particular @Id attribute mapping we encountered
     * @param sequence the EclipseLink Sequence to assign
     */
    protected void assignSequence(ClassDescriptor descriptor, DatabaseMapping mapping, org.eclipse.persistence.sequencing.Sequence sequence) {
        // this is required by EclipseLink to lookup and assign the Sequence
        descriptor.setSequenceNumberName(sequence.getName());
        // this is required by EclipseLink as a dependency of the previous setting
        descriptor.setSequenceNumberField(mapping.getField());
        // this seems to be ignored and is probably overwritten by a phase which inspects the preceeding two
        descriptor.setSequence(sequence);
    }

    @Override
    public void customize(Session session) throws Exception {
        // for each individual generated Sequence, register it with the EclipseLink Session
        for (org.eclipse.persistence.sequencing.Sequence sequence: sequences) {
            session.getLogin().addSequence(sequence);
        }
    }

    /**
     * An EclipseLink {@link org.eclipse.persistence.sequencing.Sequence} which wraps the Rice IdGenerator
     */
    private static class IdGeneratorSequenceWrapper extends org.eclipse.persistence.sequencing.Sequence {
        /**
         * The IdGenerator this Sequence defers to
         */
        private IdGenerator generator;

        private IdGeneratorSequenceWrapper(IdGenerator generator) {
            // be sure to assign an initial size of 0, otherwise base implementation
            // attempts to pre-fetch ids
            super(generator.getName(), 0);
            this.generator = generator;
        }

        @Override
        public boolean shouldAcquireValueAfterInsert() {
            return false;
        }
        @Override
        public boolean shouldUseTransaction() {
            return true;
        }

        @Override
        public boolean shouldUsePreallocation() {
            return false;
        }

        @Override
        public Object getGeneratedValue(Accessor accessor, AbstractSession writeSession, String seqName) {
            // invoke the IdGenerator with the Connection
            // Invocation of EntityManager here is:
            // 1) not practically possible without caching it on a ThreadLocal upstream
            // 2) does not work anyway because the EM will attempt to pre-emptively flush before querying
            //    which is exactly what we don't want to happen in the case we are obtaining an id for a new object
            return new JdbcTemplate(((JNDIConnector) writeSession.getLogin().getConnector()).getDataSource()).execute(new ConnectionCallback<Object>() {
                @Override
                public Object doInConnection(Connection con) throws SQLException, DataAccessException {
                    return generator.getNextValue(con);
                }
            });
        }

        @Override
        public Vector getGeneratedVector(Accessor accessor, AbstractSession writeSession, String seqName, int size) {
            // we're not in the business of pre-fetching/allocating ids
            throw new UnsupportedOperationException("IdGeneratorSequenceWrapper cannot pre-generate sequence ids");
        }
        @Override
        public void onConnect() {}
        @Override
        public void onDisconnect() {}
    }
}